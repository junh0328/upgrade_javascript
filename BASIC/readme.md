# 🌟자바스크립트 개념 정리하기 (비기너)🌟

# 들어가며

<p>&nbsp;이 책은 컴퓨터 명령에 관한 내용을 다룬다. 오늘날 컴퓨터는 스크류 드라이버만큼 흔하지만 훨씬 더 복잡하며, 컴퓨터가 우리가 원하는 작업을 처리하도록 만드는 일이 쉽지만은 않다.</p>

<p>&nbsp;<b>프로그래밍은 프로그램을 만드는 행위이다.</b> 컴퓨터가 무엇을 해야하는 지 알려주는 구체적인 명령어 집합이다. 대부분의 프로그래밍은 프로그래밍 언어를 사용한다. 프로그래밍 언어는 컴퓨터에게 명령하기 위해 인위적으로 만든 언어이다. 인간의 언어와 마찬가지로 컴퓨터 언어도 단어와 구문을 새로운 방식으로 결합해 새로운 개념을 표현할 수 있다.</p>

<p>&nbsp;<b>프로그램은 여러 가지를 의미한다.</b> 프로그램은 프로그래머가 작성한 텍스트이며, 컴퓨터가 작업을 하도록 지시하는 힘이고, 컴퓨터 메모리에 존재하는 데이터이지만 동일한 메모리상에서 처리되는 작업을 제어한다.</p>

<p>&nbsp;컴퓨터는 물리적인 머신이며, 물리적인 형태가 없는 머신의 호스트 역할을 한다. 컴퓨터 자체는 우직하게 단순한 작업만 수행할 수 있다. 그렇지만 이 컴퓨터가 유용한 이유는 이 같은 작업을 아주 빠른 속도로 처리하기 때문이다. 프로그램은 이 컴퓨터를 사용하여 생각으로 지은 건물이다. 만드는 비용이 들지 않고 무게가 없으며 타이핑하는 손 아래서 쉽게 자란다.</p>

<p>&nbsp;하지만 주의를 기울이지 않으면 프로그램의 크기와 복잡도는 통제할 수 없게 되고 프로그램을 만든 사람조차도 혼동하게 만든다. 프로그램을 통제하는 것이 프로그래밍의 핵심이다. 좋은 프로그램은 복잡도가 낮고 안정적이다. 또한 <b>좋은 프로그램에 대한 감각은 규칙 목록에서 배우는 것이 아니라 실무를 통해 만들어진다.</b></p>

<hr/>

# Chapter 1,자바스크립트란?

<p>&nbsp;자바스크립트는 1995년에 넷스케이프 내비게이터 브라우저의 웹 페이지에 프로그램을 추가하기 위한 방법으로 도입됐다. 그리고 이후 다른 모두 주요 그래픽 웹 브라우저에서 자바스크립트를 채택했다. 이를 통해 모든 동작마다 페이지를 다시 불러오지 않아도 직접 상호작용을 할 수 있는 최신의 웹 애플리케이션을 만들 수 있게 됐다.</p>

<p>&nbsp;<b>자바스크립트는 자바라는 프로그래밍 언어와 관련이 없다.</b> 이처럼 비슷한 이름은 좋은 판단이라고 하기 보다는 마케팅에 관점에서 영향을 받은 것이다.</p>

<p>&nbsp;자바스크립트를 넷스케이프 외부에서도 사용할 수 있게 된 이후에 자바스크립트 동작 방식을 설명하는 표준 문서가 작성됐으며, 자바스크립트를 지원한다고 주장하는 다양한 소프트웨어에서 실제로 동일한 언어를 사용하게 됐다. 이것은 표준화를 수행한 Ecma International 조직의 이름을 따서 ECMAScript 표준이라고 부른다. 실제로 ECMAScript와 자바스크립트라는 용어는 같은 언어의 두 가지 이름이며 서로 바꿔 사용해도 무방하다.</p>

<p>&nbsp;자바스크립트는 엄청나게 자유도가 높다. 하지만 <b>실제로는 시스템에서 문제를 지적하지 않기 때문에 프로그램의 문제를 찾기가 더 어려워진다.</b></p>

<p>&nbsp;그러나 이러한 유연성에는 장점도 존재한다. 좀 더 경직된 언어로는 불가능한 다양한 기법을 사용할 수 있도록 여지를 남겨두어 자바스크립트의 일부 단점을 극복할 때 사용할 수 있다.</p>

<p>&nbsp;자바스크립트가 사용되는 플랫폼이 브라우저만 있는 것은 아니다. MongoDB와 CouchDB 같은 일부 데이터베이스에서는 스크립트와 쿼리 언어로 자바스크립트를 사요한다. 데스크탑과 서버 프로그래밍을 위한 다양한 플랫폼에서 사용할 수 있으며, Node.js 프로젝트에서는 브라우저 외부에서 자바스크립트로 프로그래밍할 수 있는 환경을 제공한다.</p>

## 값

<p>&nbsp;보통의 최신 컴퓨터에는 휘발성 데이터 저장소(동적 메모리)에 300억개 이상의 비트(약 8GB)를 가지고 있다. 비휘발성 저장소(하드 디스크나 동종의 저장소)는 아직 규몽 면에서는 좀 더 강력하다. 이와 같은 대량의 비트를 분실하지 않고 처리하려면 정보의 조각을 나타내는 <b>청크(chunk)</b>로 분리해야 한다. 자바스크립트 환경에서는 이러한 chunk를 <b>값(value)</b>이라고 부르낟. 모든 값은 비트로 이뤄지지만 서로 다른 역할을 한다. 모든 값은 역할을 지정하는 타입을 갖는다. </p>

## 숫자

<p>&nbsp;자바스크립트에서는 하나의 숫자 값을 저장하는 데 고정된 64개의 비트를 사용한다. 64비트로 만들 수 있는 패턴은 한정돼 있다. 즉, 표현할 수 있는 여러 가지 수의 개수가 한정된다는 의미이다. N개의 십진수로는 10*(N)만큼의 숫자를 표현할 수 있다. 비슷하게 주어진 64개의 이진수로는 2*(64승) 만큼의 여러 가지 숫자를 표현할 수 있으며, 이는 약 1,800경이다. </p>

<p>&nbsp; 하지만 컴퓨터 메모리는 이보다 훨씬 더 작았었고 사람들은 숫자를 표현하는 데 8이나 16비트 그룹을 사용했었다. 이는 주어진 비트의 수에 맞지 않는 숫자가 되기 쉬웠기 때문에 뜻하지 않게 오버플로우(overflow)가 발생했다. 요즘에는 호주머니에 들어가는 컴퓨터조차 메모리가 많기 때문에 64비트 청크를 자유롭게 사용할 수 있으며 정말 천문학적인 수를 다루는 경우에만 오버플로우를 염려하면 된다.</p>

## 단항연산자

<p>&nbsp;모든 연산자가 심볼은 아니다. 일부는 단어로 구성된다. 한 예로는 typeof 연산자가 있으며 주어진 값의 타입 이름을 문자열 값으로 만든다.</p>

```
console.log(typeof 4.5)
>>> number
```

<p>&nbsp;typeof 연산자는 함수나 메소드가 아닌 연산자이기 때문에 `( )` 와 같은 소괄호로 묶어줄 필요가 없다.</p>

## 빈 값

<p>&nbsp; 여기에 `null`과 `undefined` 이라고 쓰이는 두 개의 특별한 값이 있으며 의미 있는 값이 없음을 표현하는데 사용한다. 그 자체가 값이지만 아무런 정보를 갖지 않는다. 이 언어에서 의미 있는 값을 만들지 못하는 연산에서는 어떤 값이라도 반환해야 하기 때문에 단순히 (어쩔 수 없다는 의미)의 `undefined`를 만든다.</p>

<p>&nbsp; `null`과 `undefined` 사이의 의미상 차이점은 자바스크립트 설계의 우연한 사고이며 대부분의 경우에는 문제가 되지 않는다. 실제로 이러한 값을 고려해야 하는 경우는 대부분 서로 대체가 가능한 것으로 생각하면 된다.</p>

<hr/>

# Chapter 2, 프로그램 구조

> 표현식, 구문 , 부수효과, 바인딩

## 표현식과 구문

<p>&nbsp;1장에서는 새로운 값을 얻기 위해 값을 만들고 연산자를 적용했다. 이러한 값을 만드는 것은 모든 자바스크립트 프로그램의 핵심이다. 하지만 이러한 값이 쓸모 있으려면 더 큰 구조의 틀을 만들어야 한다. 값을 생성하는 코드 조각을 <b>표현식</b>이라고 부른다. 문자 그대로 작성한 모든 값 `(예: 22, "psychoanalysis")`은 표현식이다. 표현식에서는 사람이 사용하는 언어와 유사하게 문장이 중첩되는 방식을 사용해서 다른 표현식을 포함할 수 있다. 이렇게 하면 복잡한 계산을 기술하는 표현식을 원하는 대로 만들 수 있다.</p>

<p>&nbsp;표현식이 문장 조각이라면 자바스크립트 <b>구문(statement)</b>은 전체 문장에 해당한다. 하나의 프로그램은 명령문의 목록이다. 가장 단순한 구문은 표현식과 세미콜론으로 이루어진다. 다음은 하나의 프로그램이다.</p>

```js
1;
!false;
```

<p>&nbsp;이 프로그램은 쓸모없는 프로그램이다. <b>표현식</b>은 단지 값을 생성하는 내용이며 이 값은 나중에 코드에서 사용될 수 있다. <b>구문</b>은 독립적으로 동작하며, 따라서 프로그램에 영향을 미칠 때만 어떤 동작을 하게 된다. 프로그램을 변경한다고 판단되면 화면에 무언가를 표시하거나, 또는 해당 구문 이후에 나오는 구문에 영향을 미치는 방식으로 머신의 내부 상태를 변경한다. 이러한 변경을 <b>부수 효과(side effect)</b>라고 한다. 이 예제의 구문에서는 값 1과 true를 생성한 후 즉시 버린다. 즉, 아무런 영향을 미치지 않는다. 이 프로그램을 실행하면 관찰할 수 있는 일은 일어나지 않는다.</p>

## 바인딩

> 값을 잡아 두기 위한 행위

<p>&nbsp;프로그램에서 내부 상태를 유지하는 방법은 무엇일까? 그리고 어떤 것을 기억하는 방법은 무엇일까? 지금까지의 사용 방식은 이전 값을 변경하지 않고, 새로운 값을 즉시 사용해야 하며, 그렇지 않으면 다시 없어진다. 자바스크립트에서는 다음과 같이 값을 잡아 두기 위해 <b>바인딩(binding)</b>또는 <b>변수(variable)</b>라는 것을 사용한다.</p>

```js
// let, var, const라는 키워드를 이용하여 위 구문을 바인딩한다고 정의하였음
let caught = 5 * 5;
```

<p>&nbsp;이 구문은 `caught`라는 바인딩을 생성하고 5와 5를 곱해서 생성된 숫자를 담는다. 바인딩이 정의된 후에는 해당 이름을 표현식에서 사용할 수 있다. 그러한 표현식의 값은 바인딩이 현재 담고 있는 값이다. 다음은 그 예이다.</p>

```js
let ten = 10;
console.log(ten * ten);
>>> 100
```

<p>&nbsp; 바인딩이 값을 가리키는 경우 해당 바인딩과 가리키는 값이 영원히 묶여 있음을 의미하지는 않는다. `=` 연산자를 사용해 언제든지 기존 바인딩과 현재 값의 연결을 끊고 새 값을 가리키도록 할 수 있다.</p>

```js
let mood = "light";
console.log(mood);
>>> light;

mood = "dark"
console.log(mood);
>>> dark
```

<p>&nbsp;바인딩을 <b>상자</b>보다는 연체 동물의 <b>촉수</b>처럼 생각해야 한다. 바인딩은 여러 가지 값을 담지는 않지만 그러한 값들을 움켜쥐고 있다. 두 개의 바인딩이 하나의 값을 참조할 수 있다. 프로그램에서는 계속 참조되고 있는 값에만 접근할 수 있다.</p>

## 환경

<p>&nbsp; 주어진 특정 시간에 존재하는 바인딩과 해당 바인딩의 값을 <b>환경</b>이라고 한다. 프로그램이 시작되면 이 환경은 비어 있지 않다. 이 환겨에는 언어 표준의 일부인 바인딩이 언제나 포함되며 대부분의 경우 주변 시스템과 상호작용할 수 있는 방법을 제공하는 바인딩도 포함된다. 예를 들면 브라우저에는 현재 불러온 웹 사이트와 상호작용하고 마우스와 키보드 입력을 읽어오는 함수가 존재한다.</p>

## 함수

<p>&nbsp;함수는 <b>값</b>으로 둘러싸인 프로그램이다. 따라서 이 프로그램을 작동시키려면 값을 사용할 수 있다. 함수를 실행하는 것을 <b>함수를 불러온다 (invoke)</b>, <b>호출한다 (call)</b>, <b>적용한다 (apply)</b> 라고 말한다. 함수 값을 생성하는 표현식 다음에 괄호를 사용하면 함수를 호출할 수 있다. <b>일반적으로 함수를 가지고 있는 바인딩의 이름을 직접 사용한다.</b> 괄호 안의 값은 함수 내부 프로그램에 전달된다. 함수에 전달된 값을 <b>인수 (arguments)</b>라고 한다.</p>

## 간결한 바인딩 업데이트

<p>&nbsp; 반복문과 같은 프로그램에서는 다음과 같이 바인딩의 이전 값을 기반으로 값을 저장하기 위해 바인딩을 업데이트해야 하는 경우가 있다.</p>

```js
counter = counter + 1;
```

<p>자바스크립트에서는 이러한 구문을 다음과 같이 단축하는 방법도 제공한다.</p>

```js
counter += 1;
```

<hr/>

### 👉🏼 <a href="./SECTION01/readme.md">섹션 1, 기본 문법 바로가기</a><br/>

### 👉🏼 <a href="./SECTION02/readme.md">섹션 2, 연산자 바로가기</a><br/>

### 👉🏼 <a href="./SECTION03/readme.md">섹션 3, 문장 바로가기</a><br/>

### 👉🏼 <a href="./SECTION04/readme.md">섹션 4, 함수 바로가기</a><br/>

### 👉🏼 <a href="./SECTION05/readme.md">섹션 5, Object(오브젝트) 바로가기</a><br/>

### 👉🏼 <a href="./SECTION06/readme.md">섹션 6, 빌트인 바로가기</a><br/>

### 👉🏼 <a href="./SECTION07/readme.md">섹션 7, Number 오브젝트 바로가기</a><br/>

### 👉🏼 <a href="./SECTION08/readme.md">섹션 8, String 오브젝트 바로가기</a><br/>

### 👉🏼 <a href="./SECTION09/readme.md">섹션 9, 오브젝트 (ES3) 바로가기</a><br/>

### 👉🏼 <a href="./SECTION10/readme.md">섹션 10, Function 오브젝트 바로가기</a><br/>

### 👉🏼 <a href="./SECTION11/readme.md">섹션 11, Global 오브젝트 바로가기</a><br/>

### 👉🏼 <a href="./SECTION12/readme.md">섹션 12, Array 오브젝트(ES3) 바로가기</a><br/>

### 👉🏼 <a href="./SECTION13/readme.md">섹션 13, Array 오브젝트 (ES 5) 바로가기</a><br/>

### 👉🏼 <a href="./SECTION13/readme.md">섹션 14, 자바스크립트 특징 바로가기</a><br/>

### 👉🏼 <a href="./SECTION13/readme.md">섹션 15, JSON 오브젝트 바로가기</a><br/>
